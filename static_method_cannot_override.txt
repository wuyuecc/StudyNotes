（C++也一样）

我们知道在Java中可以通过覆写（Override）来增强或减弱父类的方法和行为，但覆写是针对非静态方法（也叫做实例方法，只有生成实例才能调用的方法）的，不能针对静态方法（static修饰的方法，也叫做类方法），为什么呢？我们先看一个例子，代码如下：

    public class Client {  
         public static void main(String[] args) {  
              Base base = new Sub();  
              //调用非静态方法  
              base.doAnything();  
              //调用静态方法  
              base.doSomething();  
         }  
    }  
     
    class Base{  
         //父类静态方法  
         public static void doSomething(){  
              System.out.println("我是父类静态方法");  
         }  
         //父类非静态方法  
         public void doAnything(){  
              System.out.println("我是父类非静态方法");  
         }  
    }  
     
    class Sub extends Base{  
         //子类同名、同参数的静态方法  
         public static void doSomething(){  
              System.out.println("我是子类静态方法");  
         }  
         //覆写父类的非静态方法  
         @Override  
         public void doAnything(){  
              System.out.println("我是子类非静态方法");  
         }  
    } 

注意看程序，子类的doAnything方法覆写了父类方法，这没有任何问题，那doSomething方法呢？它与父类的方法名相同，输入、输出也相同，按道理来说应该是覆写，不过到底是不是覆写呢？我们先看输出结果：

    我是子类非静态方法  
    我是父类静态方法 

这个结果很让人困惑，同样是调用子类方法，一个执行了子类方法，一个执行了父类方法，两者的差别仅仅是有无static修饰，却得到不同的输出结果，原因何在呢？

我们知道一个实例对象有两个类型：表面类型（Apparent Type）和实际类型（Actual Type），表面类型是声明时的类型，实际类型是对象产生时的类型，比如我们例子，变量base的表面类型是Base，实际类型是Sub。对于非静态方法，它是根据对象的实际类型来执行的，也就是执行了Sub类中的doAnything方法。而对于静态方法来说就比较特殊了，首先静态方法不依赖实例对象，它是通过类名访问的；其次，可以通过对象访问静态方法，如果是通过对象调用静态方法，JVM则会通过对象的表面类型查找到静态方法的入口，继而执行之。因此上面的程序打印出“我是父类静态方法”，也就不足为奇了。

在子类中构建与父类相同的方法名、输入参数、输出参数、访问权限（权限可以扩大），并且父类、子类都是静态方法，此种行为叫做隐藏（Hide），它与覆写有两点不同：

表现形式不同。隐藏用于静态方法，覆写用于非静态方法。在代码上的表现是：@Override注解可以用于覆写，不能用于隐藏。

职责不同。隐藏的目的是为了抛弃父类静态方法，重现子类方法，例如我们的例子，Sub.doSomething的出现是为了遮盖父类的Base.doSomething方法，也就是期望父类的静态方法不要破坏子类的业务行为；而覆写则是将父类的行为增强或减弱，延续父类的职责。

静态方法不能覆写，虽然不能覆写，但是可以隐藏。顺便说一下，通过实例对象访问静态方法或静态属性不是好习惯，它给代码带来了“坏味道”，建议读者阅之戒之。
